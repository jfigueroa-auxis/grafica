<!DOCTYPE html>
<html>
    <!--Estudiante: Ingri Daniela Sepulveda MontaÃ±a - Computacion Grafica - Algoritmo:Bresenham  -->
  <body>
    <canvas id="canvas" width="640" height="640" style="border:1px solid #d3d3d3;"></canvas>
    <script src="https://pagecdn.io/lib/mathjs/10.4.0/math.min.js" crossorigin="anonymous"  ></script>
    <script src="m4.js"></script>
    <script src="graphics.js"></script>
    <script src="transformaciones.js"></script>
    <script type="application/javascript" >
        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext('2d');
        
        //vertices de todo
        let escena = {
            v: [],
            ndx: [],
            poligonos: [],
            luz: []
        };

        function inicializar(){
            corte3();
            proyectar();
            procesar(escena, canvas.height/4, canvas.height/2);
            //renderizar();
        }

        function corte3() {

            // let pl = plano(4);
            // pl = escalar(pl,3,3,3);
            // pl = trasladar(pl, 0,0,-2)
            
            // AgregarAEscena(pl, { color: [255,0,0], kd: 1, ka: 1 });

            // let pl2 = plano(4);
            // pl2 = escalar(pl2,3,3,3);
            // pl2 = rotar(pl2,0,90,0)
            // p12 = trasladar(pl2, -2,0,0)
            
            // AgregarAEscena(pl2, { color: [0,255,0], kd: 1, ka: 1 });

            let piso = plano(4);
            piso = escalar(piso,3,3,3);
            piso = rotar(piso,90,0,0)
            piso = trasladar(piso, 0,2,0)

            AgregarAEscena(piso,{ color: [0,0,255], kd: 1, ka: 1 });

            let esf = trasladar(esfera(24,12), 0,0,0);
            AgregarAEscena(esf, { color: [76, 137, 139], kd: 1, ka: 1 });

            // AgregarLuz(-4,-4,-1,1);

        }

        //crear la proyeccion 
        function proyectar(){

            //vlr iniciales
            var translation = [1, 1, 1];
            var rotation = [degToRad(30), degToRad(45), degToRad(0)];

            let escala = 0.003

            var scale = [escala,escala,escala];
            var fieldOfViewRadians = degToRad(0.5);

            //frustrum
            var aspect = canvas.clientWidth / canvas.clientHeight;
            var zNear = 0.1; 
            var zFar = 5;
            
            var matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);
            matrix = m4.translate(matrix, translation[0], translation[1], translation[2]);
            matrix = m4.xRotate(matrix, rotation[0]);
            matrix = m4.yRotate(matrix, rotation[1]);
            matrix = m4.zRotate(matrix, rotation[2]);
            matrix = m4.scale(matrix, scale[0], scale[1], scale[2]);

            let p = m4.multiply(vectorizar(escena), matrix);

            escena.v = desvectorizar(p);
        }

        function degToRad(d) {
            return d * Math.PI / 180;
        }
        
        //Agregar una primitiva a la escena 
        function AgregarAEscena(primitiva, material){
            escena.v = escena.v.concat(primitiva.v);
            
            let offset = escena.ndx.length == 0 ? 0 : Math.max(...escena.ndx) + 1;
            for (let i = 0; i < primitiva.ndx.length; i++) {
                primitiva.ndx[i] += offset;
            }

            let arrMat = [];
            for(let i = 0; i < primitiva.ndx.length / 3; i++) {
                arrMat.push({...material});
            }

            escena.ndx = escena.ndx.concat(primitiva.ndx);
            escena.poligonos = escena.poligonos.concat(arrMat);
        }

        function AgregarLuz(x,y,z,ki){
            escena.luz.push({ coord: [x,y,z], ki: ki })
            let esf = trasladar(esfera(16,8), x,y,z);
            esf = escalar(esf, 0.4,0.4,0.4)
            AgregarAEscena(esf,{ color: [243, 255, 51], kd: 1, ka: 1 });
        }

        function procesar(escena, factor_escala, desplazamiento){
            let V = escena.v
            for(let i=0; i<V.length; i++)
                V[i] = V[i]*factor_escala+desplazamiento;
            dibuja_triangulos();
        }
        
        function dibuja_triangulos(){
            let V = escena.v;
            let I = escena.ndx;

            //El vector de vertices va a grabando de  a 3 en 3 
            for(let i=0; i<I.length; i+=3){

                let indicePoligono = i/3;
                let color = escena.poligonos[indicePoligono].color
                ctx.fillStyle = 'rgb('+color[0]+', '+color[1]+', '+color[2]+')';

                let x0 = parseInt(V[I[i]*3]);
                let y0 = parseInt(V[I[i]*3+1]);
                let z0 = parseInt(V[I[i]*3+2]);

                let x1 = parseInt(V[I[i+1]*3]);
                let y1 = parseInt(V[I[i+1]*3+1]);
                let z1 = parseInt(V[I[i+1]*3+2]);

                let x2 = parseInt(V[I[i+2]*3]);
                let y2 = parseInt(V[I[i+2]*3+1]);
                let z2 = parseInt(V[I[i+2]*3+2]);

                let poligono = [
                    [ x0, y0, z0],
                    [ x1, y1, z1],
                    [ x2, y2, z2],
                ]

                calcularEcuacionDePlano(poligono, indicePoligono)

                //pinto las 3 lineas que forman el triangulo
                algoritmo_bresenham(x0, y0, x1, y1, pintar_pixel); //linea de 0 a 1  
                algoritmo_bresenham(x0, y0, x2, y2, pintar_pixel); //linea de 0 a 2
                algoritmo_bresenham(x2, y2, x1, y1, pintar_pixel);//linea de 2 a 1
            }
        }

        function algoritmo_bresenham(x0, y0, x1, y1, callback){
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var sx = (x0 < x1) ? 1 : -1;
            var sy = (y0 < y1) ? 1 : -1;
            var err = dx - dy;

            while(true){
                callback(x0, y0);
                if((x0 === x1) && (y0 === y1)) break;
                var e2 = 2*err;
                if(e2 > -dy){ err -= dy; x0 += sx; }
                if(e2 < dy){ err += dx; y0 += sy; }       
            }
        }

        function calcularEcuacionDePlano(poligono, indicePoligono){

            let u = m4.vector(poligono[0],poligono[1]);
            let v = m4.vector(poligono[0],poligono[2]);
            
            let vNormal = m4.crossProduct(u,v);

            let a = vNormal[0];
            let b = vNormal[1];
            let c = vNormal[2];
            let d = vNormal[0] * poligono[1][0] + vNormal[1] * poligono[1][1] + vNormal[2] * poligono[1][1]

            let pol = escena.poligonos[indicePoligono];
            pol.ecuacion = { a:a, b:b, c:c, d:d }
            pol.puntos = { a: poligono[0], b: poligono[1], c: poligono[2] }
        }

        function calcularZ(x,y, poligono){
            let a = poligono.ecuacion.a;
            let b = poligono.ecuacion.b;
            let c = poligono.ecuacion.c;
            let d = poligono.ecuacion.d;
            
            return -(a*x + b*y + d) / c 
        }

        function pintar_pixel(x, y){
            ctx.fillRect(x, y, 1, 1);
        }
  
        function normalizar(point){
            let x = point[0];
            let y = point[1];
            let z = point[2];

            var m = Math.sqrt(x*x + y*y + z*z);
            return [ x/m,  y/m,  z/m ]
        }

        function sign (p1, p2, p3)
        {
            return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);
        }

        function PointInTriangle (v1, v2, v3, pt)
        {
            let d1, d2, d3;
            let has_neg = false, has_pos = false;

            d1 = sign(pt, v1, v2);
            d2 = sign(pt, v2, v3);
            d3 = sign(pt, v3, v1);

            has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);
            has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);

            return !(has_neg && has_pos);
        }

        function renderizar(){
            let pixel = [];

            for (let x = 0; x < canvas.clientWidth; x++) {
                for (let y = 0; y < canvas.clientHeight; y++) {
                    
                    let z = 100000000;
                    let color = [255,255,255]

                    for (let p = 0; p < escena.poligonos.length; p++) {
                        let poligono = escena.poligonos[p];
                        let pz = calcularZ(x,y,poligono)
                        let estaContenido = PointInTriangle(poligono.puntos.a, poligono.puntos.b, poligono.puntos.c, [ x,y ])

                        if(pz < z && estaContenido)
                        {
                            z = pz;
                            color = [ poligono.color[0] - pz, poligono.color[1], poligono.color[2] ];
                        }
                    }
                    pixel.push({x,y,color})  
                }
            }

            pixel.forEach(p => {
                ctx.fillStyle = 'rgb('+p.color[0]+', '+p.color[1]+', '+p.color[2]+')';
                pintar_pixel(p.x, p.y)
            });
        }

        

        inicializar()
    </script> 
  </body>
</html>